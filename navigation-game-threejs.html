<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –°–∏–º—É–ª—è—Ç–æ—Ä –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        
        .top-panel {
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .left-panel {
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
        }
        
        .right-panel {
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
        }
        
        .bottom-panel {
            bottom: 20px;
            left: 20px;
            right: 20px;
            text-align: center;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .stat-label {
            font-size: 0.8em;
            opacity: 0.8;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            background: #4ecdc4;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: #45b7aa;
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .audio-toggle {
            background: #ff6b6b;
        }
        
        .audio-toggle.active {
            background: #4ecdc4;
        }
        
        .instructions {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        .navigation-status {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }
        
        .navigation-status.navigating {
            background: rgba(78, 205, 196, 0.3);
        }
        
        .navigation-status.reached {
            background: rgba(45, 183, 170, 0.3);
        }
        
        .minimap {
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4ecdc4;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .minimap-player {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff6b6b;
            border-radius: 50%;
            border: 2px solid white;
            transform: translate(-50%, -50%);
        }
        
        .minimap-target {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #4ecdc4;
            border-radius: 50%;
            border: 1px solid white;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-overlay">
            <!-- –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å -->
            <div class="ui-panel top-panel">
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="currentDistance">--</div>
                        <div class="stat-label">–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–ª–∏</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="currentSpeed">5</div>
                        <div class="stat-label">–°–∫–æ—Ä–æ—Å—Ç—å (–∫–º/—á)</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="pointsReached">0</div>
                        <div class="stat-label">–¢–æ—á–µ–∫ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–æ</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="gameTime">00:00</div>
                        <div class="stat-label">–í—Ä–µ–º—è –∏–≥—Ä—ã</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button id="audioToggle" class="audio-toggle">üîá –í–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫</button>
                    <button id="startGame" disabled>üéØ –ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
                    <button id="pauseGame" disabled>‚è∏Ô∏è –ü–∞—É–∑–∞</button>
                    <button id="resetGame">üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                </div>
            </div>
            
            <!-- –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å - –ú–∏–Ω–∏–∫–∞—Ä—Ç–∞ -->
            <div class="ui-panel left-panel">
                <div class="minimap" id="minimap">
                    <div class="minimap-player" id="minimapPlayer"></div>
                    <div class="minimap-target" id="minimapTarget"></div>
                </div>
            </div>
            
            <!-- –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å - –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ -->
            <div class="ui-panel right-panel">
                <div class="instructions">
                    <h4>üèÉ‚Äç‚ôÇÔ∏è –ö–∞–∫ –∏–≥—Ä–∞—Ç—å:</h4>
                    <ul>
                        <li><strong>–ë–µ–≥—É–Ω –¥–≤–∏–∂–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏</strong> –ø–æ —Ç—Ä–æ–ø–∞–º</li>
                        <li><strong>–ù–∞ —Ä–∞–∑–≤–∏–ª–∫–∞—Ö</strong> –≤—ã–±–∏—Ä–∞–π—Ç–µ —Ç—Ä–æ–ø—É –∫–Ω–æ–ø–∫–∞–º–∏</li>
                        <li><strong>–£ –≤–∞—Å 3 —Å–µ–∫—É–Ω–¥—ã</strong> –Ω–∞ –≤—ã–±–æ—Ä —Ç—Ä–æ–ø—ã</li>
                        <li><strong>–ú—ã—à—å</strong> - –ø–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</li>
                        <li><strong>ESC</strong> - –ø–∞—É–∑–∞</li>
                    </ul>
                    
                    <h4>üéØ –ü–æ–¥—Å–∫–∞–∑–∫–∏:</h4>
                    <ul>
                        <li><strong>–°–≤–µ—Ç–ª—ã–µ —Ç—Ä–æ–ø—ã</strong> - –¥–æ—Å—Ç—É–ø–Ω—ã –Ω–∞ —Ä–∞–∑–≤–∏–ª–∫–µ</li>
                        <li><strong>–ö—Ä–∞—Å–Ω—ã–µ —Å—Ñ–µ—Ä—ã</strong> - —Ü–µ–ª–∏ –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è</li>
                        <li><strong>–ö–æ—Ä–∏—á–Ω–µ–≤—ã–µ —Ü–∏–ª–∏–Ω–¥—Ä—ã</strong> - –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è</li>
                        <li><strong>–ö—Ä–∞—Å–Ω–∞—è —Å—Ñ–µ—Ä–∞ –ø–æ–¥ –Ω–æ–≥–∞–º–∏</strong> - –≤–∞—à–∞ –ø–æ–∑–∏—Ü–∏—è</li>
                    </ul>
                    
                    <h4>üîä –ó–≤—É–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏:</h4>
                    <ul>
                        <li><strong>–í—ã—Å–æ–∫–∏–π —Ç–æ–Ω:</strong> –ë–ª–∏–∑–∫–æ –∫ —Ü–µ–ª–∏</li>
                        <li><strong>–ù–∏–∑–∫–∏–π —Ç–æ–Ω:</strong> –î–∞–ª–µ–∫–æ –æ—Ç —Ü–µ–ª–∏</li>
                        <li><strong>–í–æ—Å—Ö–æ–¥—è—â–∏–π:</strong> –ü—Ä–∏–±–ª–∏–∂–∞–µ—Ç–µ—Å—å</li>
                        <li><strong>–ù–∏—Å—Ö–æ–¥—è—â–∏–π:</strong> –£–¥–∞–ª—è–µ—Ç–µ—Å—å</li>
                    </ul>
                </div>
                
                <div class="navigation-status" id="navStatus">–ì–æ—Ç–æ–≤ –∫ —Å—Ç–∞—Ä—Ç—É</div>
            </div>
            
            <!-- –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å -->
            <div class="ui-panel bottom-panel">
                <div id="directionChoices">
                    <!-- –í—ã–±–æ—Ä—ã –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script type="module">
        import { playSoundPattern, playDirectionSound, toggleAudio, isAudioOn } from './src/modules/audioModuleImproved.js';
        
        // Three.js –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer, controls;
        let player, trails = [], targetPoints = [], obstacles = [];
        
        // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let gameState = {
            isRunning: false,
            isPaused: false,
            currentTarget: null,
            playerPosition: { x: 0, y: 0, z: 0 },
            pointsReached: 0,
            startTime: null,
            gameTime: 0,
            lastDistance: null,
            availableDirections: [],
            currentTrail: null,
            trailProgress: 0,
            runnerSpeed: 0.3, // –°–∫–æ—Ä–æ—Å—Ç—å –±–µ–≥—É–Ω–∞
            isAtJunction: false,
            junctionTimeout: null
        };
        
        // DOM —ç–ª–µ–º–µ–Ω—Ç—ã
        const audioToggle = document.getElementById('audioToggle');
        const navStatus = document.getElementById('navStatus');
        const startGame = document.getElementById('startGame');
        const pauseGame = document.getElementById('pauseGame');
        const resetGame = document.getElementById('resetGame');
        const directionChoices = document.getElementById('directionChoices');
        const minimap = document.getElementById('minimap');
        const minimapPlayer = document.getElementById('minimapPlayer');
        const minimapTarget = document.getElementById('minimapTarget');
        
        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        const currentDistance = document.getElementById('currentDistance');
        const currentSpeed = document.getElementById('currentSpeed');
        const pointsReached = document.getElementById('pointsReached');
        const gameTime = document.getElementById('gameTime');
        
        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        const keys = {};
        let isMouseLocked = false;
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js
        function initThreeJS() {
            // –°—Ü–µ–Ω–∞
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // –ö–∞–º–µ—Ä–∞
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0); // –í—ã—Å–æ—Ç–∞ –≥–ª–∞–∑ —á–µ–ª–æ–≤–µ–∫–∞
            
            // –†–µ–Ω–¥–µ—Ä–µ—Ä
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // –ó–µ–º–ª—è
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x98FB98 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // –ò–≥—Ä–æ–∫ (–Ω–µ–≤–∏–¥–∏–º—ã–π –æ–±—ä–µ–∫—Ç –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏ –∫–∞–º–µ—Ä—ã)
            player = new THREE.Object3D();
            player.position.set(0, 0, 0);
            scene.add(player);
            
            // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞ (–º–∞–ª–µ–Ω—å–∫–∞—è —Å—Ñ–µ—Ä–∞ –ø–æ–¥ –Ω–æ–≥–∞–º–∏)
            const playerIndicatorGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const playerIndicatorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xff6b6b,
                transparent: true,
                opacity: 0.7
            });
            const playerIndicator = new THREE.Mesh(playerIndicatorGeometry, playerIndicatorMaterial);
            playerIndicator.position.set(0, 0.5, 0);
            scene.add(playerIndicator);
            
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π
            setupCameraControls();
            
            console.log('üéÆ Three.js –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä–æ–π
        function setupCameraControls() {
            const canvas = document.getElementById('gameCanvas');
            
            // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –º—ã—à–∏
            canvas.addEventListener('click', () => {
                if (!isMouseLocked) {
                    canvas.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isMouseLocked = document.pointerLockElement === canvas;
            });
            
            // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã –º—ã—à—å—é
            let mouseX = 0, mouseY = 0;
            document.addEventListener('mousemove', (e) => {
                if (isMouseLocked) {
                    mouseX += e.movementX * 0.002;
                    mouseY += e.movementY * 0.002;
                    mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                    
                    // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É
                    camera.rotation.y = mouseX;
                    camera.rotation.x = mouseY;
                }
            });
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã (—Ç–æ–ª—å–∫–æ ESC)
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Escape') {
                    if (gameState.isRunning) {
                        togglePause();
                    }
                }
            });
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–æ–ø
        function createTrails() {
            const trailData = [
                // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ (0,0)
                { start: { x: 0, z: 0 }, end: { x: 30, z: 0 }, direction: 'east' },
                { start: { x: 0, z: 0 }, end: { x: 0, z: 30 }, direction: 'north' },
                { start: { x: 0, z: 0 }, end: { x: -30, z: 0 }, direction: 'west' },
                { start: { x: 0, z: 0 }, end: { x: 0, z: -30 }, direction: 'south' },
                { start: { x: 0, z: 0 }, end: { x: 21, z: 21 }, direction: 'northeast' },
                { start: { x: 0, z: 0 }, end: { x: -21, z: 21 }, direction: 'northwest' },
                { start: { x: 0, z: 0 }, end: { x: 21, z: -21 }, direction: 'southeast' },
                { start: { x: 0, z: 0 }, end: { x: -21, z: -21 }, direction: 'southwest' },
                
                // –û—Ç —Ç–æ—á–∫–∏ (30,0)
                { start: { x: 30, z: 0 }, end: { x: 60, z: 0 }, direction: 'east' },
                { start: { x: 30, z: 0 }, end: { x: 30, z: 30 }, direction: 'north' },
                { start: { x: 30, z: 0 }, end: { x: 30, z: -30 }, direction: 'south' },
                
                // –û—Ç —Ç–æ—á–∫–∏ (0,30)
                { start: { x: 0, z: 30 }, end: { x: 0, z: 60 }, direction: 'north' },
                { start: { x: 0, z: 30 }, end: { x: 30, z: 30 }, direction: 'east' },
                { start: { x: 0, z: 30 }, end: { x: -30, z: 30 }, direction: 'west' },
                
                // –û—Ç —Ç–æ—á–∫–∏ (-30,0)
                { start: { x: -30, z: 0 }, end: { x: -60, z: 0 }, direction: 'west' },
                { start: { x: -30, z: 0 }, end: { x: -30, z: 30 }, direction: 'north' },
                { start: { x: -30, z: 0 }, end: { x: -30, z: -30 }, direction: 'south' },
                
                // –û—Ç —Ç–æ—á–∫–∏ (0,-30)
                { start: { x: 0, z: -30 }, end: { x: 0, z: -60 }, direction: 'south' },
                { start: { x: 0, z: -30 }, end: { x: 30, z: -30 }, direction: 'east' },
                { start: { x: 0, z: -30 }, end: { x: -30, z: -30 }, direction: 'west' }
            ];
            
            trailData.forEach((trail, index) => {
                const geometry = new THREE.BoxGeometry(2, 0.1, 30);
                const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trailMesh = new THREE.Mesh(geometry, material);
                
                // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º —Ç—Ä–æ–ø—É
                const midX = (trail.start.x + trail.end.x) / 2;
                const midZ = (trail.start.z + trail.end.z) / 2;
                trailMesh.position.set(midX, 0.05, midZ);
                
                // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Ç—Ä–æ–ø—É
                const angle = Math.atan2(trail.end.z - trail.start.z, trail.end.x - trail.start.x);
                trailMesh.rotation.y = angle;
                
                trailMesh.castShadow = true;
                trailMesh.receiveShadow = true;
                
                // –î–æ–±–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ —Ç—Ä–æ–ø—ã
                trailMesh.userData = { 
                    id: index, 
                    start: trail.start, 
                    end: trail.end, 
                    direction: trail.direction 
                };
                
                scene.add(trailMesh);
                trails.push(trailMesh);
            });
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Ü–µ–ª–µ–≤—ã—Ö —Ç–æ—á–µ–∫
        function createTargetPoints() {
            const targetData = [
                { x: 60, z: 0 },
                { x: 0, z: 60 },
                { x: -60, z: 0 },
                { x: 0, z: -60 },
                { x: 21, z: 21 },
                { x: -21, z: 21 },
                { x: 21, z: -21 },
                { x: -21, z: -21 }
            ];
            
            targetData.forEach((point, index) => {
                const geometry = new THREE.SphereGeometry(2, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: 0x4ecdc4 });
                const targetMesh = new THREE.Mesh(geometry, material);
                
                targetMesh.position.set(point.x, 1, point.z);
                targetMesh.castShadow = true;
                
                targetMesh.userData = { 
                    id: index, 
                    x: point.x, 
                    z: point.z, 
                    reached: false 
                };
                
                scene.add(targetMesh);
                targetPoints.push(targetMesh);
            });
            
            // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Ü–µ–ª—å
            gameState.currentTarget = targetPoints[Math.floor(Math.random() * targetPoints.length)];
            gameState.currentTarget.material.color.setHex(0xff6b6b);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
        function createObstacles() {
            const obstacleData = [
                { x: 15, z: 15, size: 3 },
                { x: -15, z: 15, size: 2.5 },
                { x: 15, z: -15, size: 3.5 },
                { x: -15, z: -15, size: 2 },
                { x: 45, z: 15, size: 4 },
                { x: -45, z: 15, size: 3 },
                { x: 15, z: 45, size: 2.5 },
                { x: -15, z: 45, size: 3.5 }
            ];
            
            obstacleData.forEach(obstacle => {
                const geometry = new THREE.CylinderGeometry(obstacle.size, obstacle.size, 8, 8);
                const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const obstacleMesh = new THREE.Mesh(geometry, material);
                
                obstacleMesh.position.set(obstacle.x, 4, obstacle.z);
                obstacleMesh.castShadow = true;
                obstacleMesh.receiveShadow = true;
                
                scene.add(obstacleMesh);
                obstacles.push(obstacleMesh);
            });
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        function updateGameState() {
            if (!gameState.isRunning || gameState.isPaused) return;
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –±–µ–≥—É–Ω–∞ –≤–ø–µ—Ä–µ–¥
            if (gameState.currentTrail) {
                // –î–≤–∏–≥–∞–µ–º—Å—è –ø–æ —Ç–µ–∫—É—â–µ–π —Ç—Ä–æ–ø–µ
                const trailData = gameState.currentTrail.userData;
                const dx = trailData.end.x - trailData.start.x;
                const dz = trailData.end.z - trailData.start.z;
                const trailLength = Math.sqrt(dx * dx + dz * dz);
                
                // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ —Ç—Ä–æ–ø–µ
                gameState.trailProgress += gameState.runnerSpeed;
                
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
                const progressRatio = gameState.trailProgress / trailLength;
                
                if (progressRatio >= 1) {
                    // –î–æ—Å—Ç–∏–≥–ª–∏ –∫–æ–Ω—Ü–∞ —Ç—Ä–æ–ø—ã - –∏—â–µ–º —Ä–∞–∑–≤–∏–ª–∫—É
                    gameState.playerPosition.x = trailData.end.x;
                    gameState.playerPosition.z = trailData.end.z;
                    gameState.currentTrail = null;
                    gameState.trailProgress = 0;
                    checkForJunction();
                } else {
                    // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –ø–æ —Ç—Ä–æ–ø–µ
                    gameState.playerPosition.x = trailData.start.x + dx * progressRatio;
                    gameState.playerPosition.z = trailData.start.z + dz * progressRatio;
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã –∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
                camera.position.x = gameState.playerPosition.x;
                camera.position.z = gameState.playerPosition.z;
                
                const playerIndicator = scene.children.find(child => 
                    child.geometry && child.geometry.type === 'SphereGeometry' && 
                    child.material.color.getHex() === 0xff6b6b
                );
                if (playerIndicator) {
                    playerIndicator.position.x = gameState.playerPosition.x;
                    playerIndicator.position.z = gameState.playerPosition.z;
                }
            } else if (!gameState.isAtJunction) {
                // –ï—Å–ª–∏ –Ω–µ—Ç —Ç–µ–∫—É—â–µ–π —Ç—Ä–æ–ø—ã –∏ –Ω–µ –Ω–∞ —Ä–∞–∑–≤–∏–ª–∫–µ - –∏—â–µ–º –±–ª–∏–∂–∞–π—à—É—é —Ç—Ä–æ–ø—É
                findNearestTrail();
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–≤–∏–≥–∞—Ü–∏—é
            updateNavigation();
            updateMinimap();
            checkTargetReached();
        }
        
        // –ü–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–µ–π —Ç—Ä–æ–ø—ã
        function findNearestTrail() {
            const currentPos = gameState.playerPosition;
            let nearestTrail = null;
            let minDistance = Infinity;
            
            trails.forEach(trail => {
                const trailData = trail.userData;
                const distance = Math.sqrt(
                    Math.pow(trailData.start.x - currentPos.x, 2) + 
                    Math.pow(trailData.start.z - currentPos.z, 2)
                );
                
                if (distance < minDistance && distance < 5) {
                    minDistance = distance;
                    nearestTrail = trail;
                }
            });
            
            if (nearestTrail) {
                gameState.currentTrail = nearestTrail;
                gameState.trailProgress = 0;
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–∞–∑–≤–∏–ª–∫—É
        function checkForJunction() {
            const currentPos = gameState.playerPosition;
            const availableTrails = trails.filter(trail => {
                const trailData = trail.userData;
                return Math.abs(trailData.start.x - currentPos.x) < 3 && 
                       Math.abs(trailData.start.z - currentPos.z) < 3;
            });
            
            if (availableTrails.length > 1) {
                // –ú—ã –Ω–∞ —Ä–∞–∑–≤–∏–ª–∫–µ!
                gameState.isAtJunction = true;
                gameState.availableDirections = availableTrails;
                updateAvailableDirections();
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—ã–±–æ—Ä —Ç—Ä–æ–ø –Ω–∞ 3 —Å–µ–∫—É–Ω–¥—ã
                navStatus.textContent = 'üõ§Ô∏è –í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–æ–ø—É!';
                navStatus.className = 'navigation-status navigating';
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–±–æ—Ä —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã, –µ—Å–ª–∏ –∏–≥—Ä–æ–∫ –Ω–µ –≤—ã–±—Ä–∞–ª
                gameState.junctionTimeout = setTimeout(() => {
                    if (gameState.isAtJunction) {
                        // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Ç—Ä–æ–ø—É
                        const randomTrail = availableTrails[Math.floor(Math.random() * availableTrails.length)];
                        selectTrail(randomTrail);
                    }
                }, 3000);
            } else if (availableTrails.length === 1) {
                // –¢–æ–ª—å–∫–æ –æ–¥–Ω–∞ —Ç—Ä–æ–ø–∞ - –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
                gameState.currentTrail = availableTrails[0];
                gameState.trailProgress = 0;
            } else {
                // –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç—Ä–æ–ø - –∏—â–µ–º –±–ª–∏–∂–∞–π—à—É—é
                findNearestTrail();
            }
        }
        
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
        function updateAvailableDirections() {
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç—Ä–æ–ø—ã –Ω–∞ —Ä–∞–∑–≤–∏–ª–∫–µ
            trails.forEach(trail => {
                const isAvailable = gameState.availableDirections.includes(trail);
                if (isAvailable) {
                    trail.material.color.setHex(0xDEB887); // –°–≤–µ—Ç–ª–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π –¥–ª—è –¥–æ—Å—Ç—É–ø–Ω—ã—Ö
                    trail.material.emissive.setHex(0x222222); // –°–ª–∞–±–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ
                } else {
                    trail.material.color.setHex(0x8B4513); // –û–±—ã—á–Ω—ã–π –∫–æ—Ä–∏—á–Ω–µ–≤—ã–π
                    trail.material.emissive.setHex(0x000000); // –ë–µ–∑ —Å–≤–µ—á–µ–Ω–∏—è
                }
            });
            
            updateDirectionChoices();
        }
        
        // –í—ã–±–æ—Ä —Ç—Ä–æ–ø—ã
        function selectTrail(trail) {
            if (gameState.junctionTimeout) {
                clearTimeout(gameState.junctionTimeout);
                gameState.junctionTimeout = null;
            }
            
            gameState.isAtJunction = false;
            gameState.currentTrail = trail;
            gameState.trailProgress = 0;
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Ç—Ä–æ–ø
            trails.forEach(trail => {
                trail.material.color.setHex(0x8B4513);
                trail.material.emissive.setHex(0x000000);
            });
            
            navStatus.textContent = 'üèÉ‚Äç‚ôÇÔ∏è –ë–µ–∂–∏–º –ø–æ —Ç—Ä–æ–ø–µ...';
            navStatus.className = 'navigation-status navigating';
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—ã–±–æ—Ä–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
        function updateDirectionChoices() {
            if (gameState.availableDirections.length === 0) {
                directionChoices.innerHTML = '<div style="color: #666;">–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç—Ä–æ–ø</div>';
                return;
            }
            
            const choicesHtml = gameState.availableDirections.map(trail => {
                const directionNames = {
                    'north': '‚¨ÜÔ∏è –°–µ–≤–µ—Ä',
                    'south': '‚¨áÔ∏è –Æ–≥',
                    'east': '‚û°Ô∏è –í–æ—Å—Ç–æ–∫',
                    'west': '‚¨ÖÔ∏è –ó–∞–ø–∞–¥',
                    'northeast': '‚ÜóÔ∏è –°–µ–≤–µ—Ä–æ-–≤–æ—Å—Ç–æ–∫',
                    'northwest': '‚ÜñÔ∏è –°–µ–≤–µ—Ä–æ-–∑–∞–ø–∞–¥',
                    'southeast': '‚ÜòÔ∏è –Æ–≥–æ-–≤–æ—Å—Ç–æ–∫',
                    'southwest': '‚ÜôÔ∏è –Æ–≥–æ-–∑–∞–ø–∞–¥'
                };
                
                return `
                    <button onclick="selectDirection(${trail.userData.id})" style="margin: 5px;">
                        ${directionNames[trail.userData.direction]}
                    </button>
                `;
            }).join('');
            
            directionChoices.innerHTML = choicesHtml;
        }
        
        // –í—ã–±–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        window.selectDirection = function(trailId) {
            if (!gameState.isRunning || gameState.isPaused || !gameState.isAtJunction) return;
            
            const trail = trails.find(t => t.userData.id === trailId);
            if (!trail) return;
            
            selectTrail(trail);
        };
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
        function updateNavigation() {
            if (!gameState.currentTarget) return;
            
            const distance = Math.sqrt(
                Math.pow(gameState.currentTarget.userData.x - gameState.playerPosition.x, 2) + 
                Math.pow(gameState.currentTarget.userData.z - gameState.playerPosition.z, 2)
            );
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            currentDistance.textContent = Math.round(distance) + '–º';
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è
            let direction = 'neutral';
            if (gameState.lastDistance !== null) {
                if (distance < gameState.lastDistance - 2) {
                    direction = 'approaching';
                } else if (distance > gameState.lastDistance + 2) {
                    direction = 'moving_away';
                }
            }
            
            // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
            if (isAudioOn() && gameState.isRunning) {
                let pattern;
                if (distance < 20) {
                    pattern = [100]; // –û—á–µ–Ω—å –±–ª–∏–∑–∫–æ
                } else if (distance < 40) {
                    pattern = [150]; // –ì–æ—Ä—è—á–æ
                } else if (distance < 70) {
                    pattern = [200]; // –¢–µ–ø–ª–æ
                } else if (distance < 100) {
                    pattern = [250]; // –ü—Ä–æ—Ö–ª–∞–¥–Ω–æ
                } else {
                    pattern = [300]; // –•–æ–ª–æ–¥–Ω–æ
                }
                
                playSoundPattern(pattern, direction, distance);
                
                if (direction !== 'neutral') {
                    setTimeout(() => playDirectionSound(direction), 200);
                }
            }
            
            gameState.lastDistance = distance;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
            if (distance < 20) {
                navStatus.textContent = 'üéØ –û—á–µ–Ω—å –±–ª–∏–∑–∫–æ!';
                navStatus.className = 'navigation-status navigating';
            } else if (distance < 100) {
                navStatus.textContent = `üìç ${Math.round(distance)}–º –¥–æ —Ü–µ–ª–∏`;
                navStatus.className = 'navigation-status navigating';
            } else {
                navStatus.textContent = `üìç ${Math.round(distance)}–º –¥–æ —Ü–µ–ª–∏`;
                navStatus.className = 'navigation-status';
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ü–µ–ª–∏
        function checkTargetReached() {
            if (!gameState.currentTarget) return;
            
            const distance = Math.sqrt(
                Math.pow(gameState.currentTarget.userData.x - gameState.playerPosition.x, 2) + 
                Math.pow(gameState.currentTarget.userData.z - gameState.playerPosition.z, 2)
            );
            
            if (distance < 15) {
                // –¶–µ–ª—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞!
                gameState.currentTarget.userData.reached = true;
                gameState.currentTarget.material.color.setHex(0x45b7aa);
                gameState.pointsReached++;
                
                // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ü–µ–ª–∏
                if (isAudioOn()) {
                    playSoundPattern([200, 100, 200, 100, 200], 'neutral', 0);
                }
                
                navStatus.textContent = 'üéâ –¶–µ–ª—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞!';
                navStatus.className = 'navigation-status reached';
                
                // –í—ã–±–∏—Ä–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é —Ü–µ–ª—å
                setTimeout(() => {
                    const unreachedPoints = targetPoints.filter(p => !p.userData.reached);
                    if (unreachedPoints.length > 0) {
                        gameState.currentTarget = unreachedPoints[Math.floor(Math.random() * unreachedPoints.length)];
                        gameState.currentTarget.material.color.setHex(0xff6b6b);
                        gameState.lastDistance = null;
                        navStatus.textContent = 'üéØ –ù–æ–≤–∞—è —Ü–µ–ª—å –≤—ã–±—Ä–∞–Ω–∞!';
                        navStatus.className = 'navigation-status navigating';
                    } else {
                        // –í—Å–µ —Ü–µ–ª–∏ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç—ã!
                        endGame();
                    }
                }, 2000);
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∏–Ω–∏–∫–∞—Ä—Ç—ã
        function updateMinimap() {
            const scale = 1.5;
            const centerX = minimap.clientWidth / 2;
            const centerY = minimap.clientHeight / 2;
            
            // –û—á–∏—â–∞–µ–º –º–∏–Ω–∏–∫–∞—Ä—Ç—É
            minimap.innerHTML = '';
            
            // –†–∏—Å—É–µ–º —Ç—Ä–æ–ø—ã –Ω–∞ –º–∏–Ω–∏–∫–∞—Ä—Ç–µ
            const minimapCanvas = document.createElement('canvas');
            minimapCanvas.width = minimap.clientWidth;
            minimapCanvas.height = minimap.clientHeight;
            minimapCanvas.style.position = 'absolute';
            minimapCanvas.style.top = '0';
            minimapCanvas.style.left = '0';
            minimapCanvas.style.zIndex = '1';
            minimap.appendChild(minimapCanvas);
            
            const minimapCtx = minimapCanvas.getContext('2d');
            
            // –†–∏—Å—É–µ–º —Ç—Ä–æ–ø—ã
            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            minimapCtx.lineWidth = 2;
            minimapCtx.lineCap = 'round';
            
            trails.forEach(trail => {
                const trailData = trail.userData;
                const startX = centerX + trailData.start.x * scale;
                const startY = centerY - trailData.start.z * scale;
                const endX = centerX + trailData.end.x * scale;
                const endY = centerY - trailData.end.z * scale;
                
                minimapCtx.beginPath();
                minimapCtx.moveTo(startX, startY);
                minimapCtx.lineTo(endX, endY);
                minimapCtx.stroke();
            });
            
            // –†–∏—Å—É–µ–º —Ü–µ–ª–µ–≤—ã–µ —Ç–æ—á–∫–∏
            targetPoints.forEach(point => {
                const pointData = point.userData;
                const pointX = centerX + pointData.x * scale;
                const pointY = centerY - pointData.z * scale;
                
                const pointElement = document.createElement('div');
                pointElement.className = 'minimap-target';
                pointElement.style.left = pointX + 'px';
                pointElement.style.top = pointY + 'px';
                pointElement.style.zIndex = '3';
                if (pointData.reached) {
                    pointElement.style.background = '#45b7aa';
                }
                minimap.appendChild(pointElement);
            });
            
            // –ü–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞
            minimapPlayer.style.left = centerX + 'px';
            minimapPlayer.style.top = centerY + 'px';
            minimapPlayer.style.zIndex = '4';
            minimap.appendChild(minimapPlayer);
            
            // –ü–æ–∑–∏—Ü–∏—è —Ç–µ–∫—É—â–µ–π —Ü–µ–ª–∏
            if (gameState.currentTarget) {
                const targetData = gameState.currentTarget.userData;
                const targetX = centerX + targetData.x * scale;
                const targetY = centerY - targetData.z * scale;
                
                minimapTarget.style.left = targetX + 'px';
                minimapTarget.style.top = targetY + 'px';
                minimapTarget.style.zIndex = '5';
                minimapTarget.style.background = '#ff6b6b';
                minimapTarget.style.border = '2px solid white';
                minimap.appendChild(minimapTarget);
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        function updateStats() {
            pointsReached.textContent = gameState.pointsReached;
            
            if (gameState.startTime) {
                gameState.gameTime = Math.floor((Date.now() - gameState.startTime) / 1000);
                const minutes = Math.floor(gameState.gameTime / 60);
                const seconds = gameState.gameTime % 60;
                gameTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏–≥—Ä—ã
        function endGame() {
            gameState.isRunning = false;
            startGame.disabled = false;
            pauseGame.disabled = true;
            
            navStatus.textContent = 'üèÜ –í—Å–µ —Ü–µ–ª–∏ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç—ã!';
            navStatus.className = 'navigation-status reached';
            
            alert(`üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ –≤—Å–µ—Ö —Ü–µ–ª–µ–π –∑–∞ ${gameTime.textContent}!`);
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –ø–∞—É–∑—ã
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            pauseGame.textContent = gameState.isPaused ? '‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å' : '‚è∏Ô∏è –ü–∞—É–∑–∞';
            navStatus.textContent = gameState.isPaused ? '‚è∏Ô∏è –ò–≥—Ä–∞ –Ω–∞ –ø–∞—É–∑–µ' : 'üèÉ‚Äç‚ôÇÔ∏è –ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è';
        }
        
        // –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function gameLoop() {
            updateGameState();
            updateStats();
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
        audioToggle.addEventListener('click', () => {
            const isOn = toggleAudio();
            audioToggle.textContent = isOn ? 'üîä –û—Ç–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫' : 'üîá –í–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫';
            audioToggle.className = `audio-toggle ${isOn ? 'active' : ''}`;
        });
        
        startGame.addEventListener('click', () => {
            gameState.isRunning = true;
            gameState.isPaused = false;
            gameState.startTime = Date.now();
            gameState.lastDistance = null;
            
            startGame.disabled = true;
            pauseGame.disabled = false;
            
            navStatus.textContent = 'üèÉ‚Äç‚ôÇÔ∏è –ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å!';
            navStatus.className = 'navigation-status navigating';
            
            updateAvailableDirections();
            updateNavigation();
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            const statsInterval = setInterval(() => {
                if (!gameState.isRunning) {
                    clearInterval(statsInterval);
                    return;
                }
                updateStats();
            }, 1000);
        });
        
        pauseGame.addEventListener('click', togglePause);
        
        resetGame.addEventListener('click', () => {
            // –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç —Ä–∞–∑–≤–∏–ª–∫–∏
            if (gameState.junctionTimeout) {
                clearTimeout(gameState.junctionTimeout);
            }
            
            gameState = {
                isRunning: false,
                isPaused: false,
                currentTarget: null,
                playerPosition: { x: 0, y: 0, z: 0 },
                pointsReached: 0,
                startTime: null,
                gameTime: 0,
                lastDistance: null,
                availableDirections: [],
                currentTrail: null,
                trailProgress: 0,
                runnerSpeed: 0.3,
                isAtJunction: false,
                junctionTimeout: null
            };
            
            startGame.disabled = false;
            pauseGame.disabled = true;
            pauseGame.textContent = '‚è∏Ô∏è –ü–∞—É–∑–∞';
            
            navStatus.textContent = '–ì–æ—Ç–æ–≤ –∫ —Å—Ç–∞—Ä—Ç—É';
            navStatus.className = 'navigation-status';
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã
            camera.position.set(0, 1.6, 0);
            camera.rotation.set(0, 0, 0);
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ü–µ–ª–∏
            targetPoints.forEach(point => {
                point.userData.reached = false;
                point.material.color.setHex(0x4ecdc4);
            });
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Ç—Ä–æ–ø
            trails.forEach(trail => {
                trail.material.color.setHex(0x8B4513);
                trail.material.emissive.setHex(0x000000);
            });
            
            // –í—ã–±–∏—Ä–∞–µ–º –Ω–æ–≤—É—é —Ü–µ–ª—å
            gameState.currentTarget = targetPoints[Math.floor(Math.random() * targetPoints.length)];
            gameState.currentTarget.material.color.setHex(0xff6b6b);
            
            updateMinimap();
            updateStats();
        });
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        document.addEventListener('DOMContentLoaded', () => {
            initThreeJS();
            createTrails();
            createTargetPoints();
            createObstacles();
            updateMinimap();
            updateStats();
            gameLoop();
            console.log('üéÆ Three.js –ò–≥—Ä–∞-—Å–∏–º—É–ª—è—Ç–æ—Ä –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
        });
    </script>
</body>
</html>
